#!/usr/bin/env ruby

require "dbml2mmd"
require "json"
require "slop"
require "dbml"

class DBMLParser
  def self.parse(content)
    # Use the dbml gem (required dependency)
    parser = DBML::Parser.new
    result = parser.parse(content)
    convert_to_standard_format(result)
  end
  
  # Convert dbml gem output to standard format
  def self.convert_to_standard_format(result)
    standard = { tables: [], refs: [] }
    
    # Process tables
    result.tables.each do |table|
      fields = table.columns.map do |column|
        {
          name: column.name,
          type: column.type,
          attributes: column.settings&.join(',')
        }
      end
      
      standard[:tables] << {
        name: table.name,
        fields: fields
      }
    end
    
    # Process references
    result.refs.each do |ref|
      endpoint1 = ref.endpoints.first
      endpoint2 = ref.endpoints.last
      
      standard[:refs] << {
        from: { table: endpoint1.tableName, field: endpoint1.columnName },
        to: { table: endpoint2.tableName, field: endpoint2.columnName },
        type: determine_relationship_type(ref)
      }
    end
    
    standard
  end
  
  # Determine relationship type from dbml gem reference
  def self.determine_relationship_type(ref)
    endpoint1, endpoint2 = ref.endpoints.first, ref.endpoints.last
    
    case [endpoint1.relation, endpoint2.relation]
    when ['1', '1'] then 'one_to_one'
    when ['1', '*'] then 'one_to_many'
    when ['*', '1'] then 'many_to_one'
    when ['*', '*'] then 'many_to_many'
    else 'one_to_one' # Default
    end
  end
end

class Dbml2Mermaid
  attr_reader :last_output
  
  def initialize(options = {})
    @options = options
    @theme = options[:theme] || 'default'
    @last_output = nil
  end

  def convert(dbml_content)
    # Parse DBML content
    dbml = DBMLParser.parse(dbml_content)
    tables = dbml[:tables] || []
    refs = dbml[:refs] || []
    
    # Filter tables if specified
    if (table_list = @options[:only_tables])
      table_names = table_list.split(',').map(&:strip)
      tables = tables.select { |table| table_names.include?(table[:name]) }
      # Only keep references between included tables
      refs = refs.select do |ref| 
        table_names.include?(ref[:from][:table]) && table_names.include?(ref[:to][:table])
      end
    end

    # Generate Mermaid ERD
    mermaid = ["erDiagram"]
    
    # Add tables and their fields
    tables.each do |table|
      table_fields = table[:fields].map do |field|
        field_type = field[:type].to_s.gsub(/\s+/, "")
        
        # Check for primary key and foreign key attributes
        is_pk = field[:attributes]&.include?('primary key')
        is_fk = refs.any? { |ref| ref[:from][:table] == table[:name] && ref[:from][:field] == field[:name] }
        
        field_annotation = []
        field_annotation << "PK" if is_pk
        field_annotation << "FK" if is_fk
        
        annotation_str = field_annotation.empty? ? "" : " #{field_annotation.join(',')}"
        
        # Format the field with proper spacing
        "    #{field[:name]} #{field_type}#{annotation_str}"
      end
      
      mermaid << "  #{table[:name]} {"
      mermaid.concat(table_fields)
      mermaid << "  }"
    end
    
    # Add relationships with proper labels
    refs.each do |ref|
      from_table = ref[:from][:table]
      to_table = ref[:to][:table]
      relationship_type = get_relationship_type(ref[:type])
      
      # Create a descriptive label
      label_text = "#{ref[:from][:field]} -> #{ref[:to][:field]}"
      label = ref[:name] ? "\"#{ref[:name]}: #{label_text}\"" : "\"#{label_text}\""
      
      mermaid << "  #{from_table} #{relationship_type} #{to_table} : #{label}"
    end
    
    # Add a header comment with generation info and theme
    theme_config = get_theme_config(@theme)
    header = [
      "%%{init: #{theme_config}}%%",
      "% Generated by dbml2mmd on #{Time.now.strftime('%Y-%m-%d %H:%M:%S')}",
      "% https://mermaid.js.org/syntax/entityRelationshipDiagram.html"
    ]
    
    # Save and return the full diagram
    @last_output = (header + [mermaid.join("\n")]).join("\n")
  end
  
  def output_html
    return nil unless @options[:html_output]
    return nil unless @last_output
    
    <<~HTML
      <!DOCTYPE html>
      <html>
      <head>
        <meta charset="utf-8">
        <title>Database Diagram</title>
        <script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
        <style>
          body { font-family: sans-serif; margin: 20px; }
          .mermaid { margin: 20px auto; }
        </style>
      </head>
      <body>
        <h1>Database Diagram</h1>
        <p>Generated on #{Time.now.strftime('%Y-%m-%d %H:%M:%S')}</p>
        <div class="mermaid">
      #{@last_output}
        </div>
        <script>
          mermaid.initialize({ startOnLoad: true });
        </script>
      </body>
      </html>
    HTML
  end
  
  private
  
  def get_relationship_type(type)
    case type
    when 'one_to_one' then "||--||"
    when 'one_to_many' then "||--o{"
    when 'many_to_one' then "}o--||"
    when 'many_to_many' then "}o--o{"
    else "--"
    end
  end
  
  def get_theme_config(theme)
    case theme
    when 'dark'
      "{'theme': 'dark', 'themeVariables': { 'primaryColor': '#2A2A2A', 'primaryBorderColor': '#777', 'primaryTextColor': '#DDD' }}"
    when 'neutral'
      "{'theme': 'neutral', 'themeVariables': { 'primaryColor': '#f4f4f4', 'primaryBorderColor': '#888', 'primaryTextColor': '#333' }}"
    when 'forest'
      "{'theme': 'forest', 'themeVariables': { 'primaryColor': '#e6f5e6', 'primaryBorderColor': '#4d994d', 'primaryTextColor': '#1a331a' }}"
    else # default theme
      "{'theme': 'default', 'themeVariables': { 'primaryColor': '#f4f4f4', 'primaryBorderColor': '#aaa', 'primaryTextColor': '#333' }}"
    end
  end
end

# Parse command-line arguments with Slop
begin
  opts = Slop.parse do |o|
    o.banner = "Usage: dbml2mmd [options] [input_file]"
    
    o.string '-o', '--output', 'Output to file instead of stdout'
    o.bool '-h', '--help', 'Show this help message', default: false
    o.string '-t', '--theme', 'Mermaid theme (default, dark, neutral, forest)', default: 'default'
    o.bool '--html', 'Generate HTML output with embedded Mermaid viewer', default: false
    o.string '--only', 'Only include specific tables (comma-separated list)'
    o.bool '-v', '--verbose', 'Enable verbose output', default: false
    
    o.on '--version', 'Print the version' do
      puts "DBML to Mermaid Converter v0.1.0"
      exit
    end
  end

  # Show help by default when no arguments are provided
  if (ARGV.empty? && STDIN.tty?) || opts.help?
    puts opts
    puts "\nExamples:"
    puts "  dbml2mmd input.dbml                    # Convert file and output to stdout"
    puts "  dbml2mmd -o output.mmd input.dbml      # Convert file and save to output.mmd"
    puts "  dbml2mmd --html -o output.html input.dbml  # Generate HTML with Mermaid viewer"
    puts "  dbml2mmd --theme dark input.dbml       # Use dark theme for diagram"
    puts "  dbml2mmd --only users,posts input.dbml # Only include specific tables"
    puts "  cat input.dbml | dbml2mmd              # Read from stdin and output to stdout"
    
    exit
  end
  
  # Get input from file or stdin
  input = if ARGV.empty?
    ARGF.read
  else
    begin
      File.read(ARGV[0])
    rescue Errno::ENOENT
      puts "Error: File not found: #{ARGV[0]}"
      exit 1
    end
  end
  
  # Setup converter options
  converter_options = {
    theme: opts[:theme],
    html_output: opts[:html],
    only_tables: opts[:only],
    verbose: opts[:verbose]
  }
  
  # Print verbose info if enabled
  if opts[:verbose]
    puts "Input source: #{ARGV.empty? ? 'STDIN' : ARGV[0]}"
    puts "Theme: #{opts[:theme]}"
    puts "HTML output: #{opts[:html]}"
    puts "Filtering tables: #{opts[:only] || 'No'}"
  end
  
  # Convert DBML to Mermaid
  converter = Dbml2Mermaid.new(converter_options)
  mermaid = converter.convert(input)
  
  # Output result
  if opts[:output]
    output = opts[:html] ? converter.output_html : mermaid
    File.write(opts[:output], output)
    puts "Output written to #{opts[:output]}"
  else
    puts mermaid
  end
  
rescue Slop::Error => e
  puts "Error: #{e.message}"
  puts opts
  exit 1
rescue => e
  puts "Error: #{e.message}"
  puts e.backtrace if opts&.verbose?
  puts opts
  exit 1
end
